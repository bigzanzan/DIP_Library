import cv2import numpy as npfrom scipy.signal import convolve2dfrom PIL import Imagefrom numpy.fft import fft2, fftshiftdef calculate_psd(image):    psd = fftshift(fft2(image))    psd = abs(psd)    return psddef BWband(L:int, H:int):    image = Image.new("L",(L,H),255)    img = np.array(image)    image2 = cv2.copyMakeBorder(img,160-int(L/2),160-int(L/2),100-int(H/2),100-int(H/2),borderType=cv2.BORDER_CONSTANT,value=0)    return image2def Picture_shoot(image_name:str, path:str):    cap = cv2.VideoCapture(0)    i=0    while cap.isOpened():        ret, frame = cap.read()        cv2.imwrite(path + image_name, frame)        if i == 5:            print("保存" + image_name + "成功！")            break        else:            i = i + 1    cap.release()    cv2.destroyAllWindows()def reduce_gray_level(img, level: int):    img = cv2.copyTo(img, None)    for x in range(img.shape[0]):        for y in range(img.shape[1]):            s = img[x, y]            n = int(level * s / 255+0.5)            img[x,y]= n    return imgdef gray_inverse(img):    img1 = np.array(img)    img2 = 255 - img1    return img2def image_log(c, img):    output = c * np.log(1.0 + img)    output = np.uint8(output)    return outputdef fitler(model, image):    image2 = convolve2d(image, model, mode='same')    return image2def array2gray(array):    array *= 255    figure = Image.fromarray(np.uint8(array))    gray = figure.convert('L')    return graydef get_noise(image,mode,sigma,amount):    if mode == 'gauss':        mean = 0        gauss = np.random.normal(mean, sigma, (image.shape[0],image.shape[1]))        noisy_img = image + gauss        noisy_img = np.clip(noisy_img, a_min=0, a_max=255)        return noisy_img    if mode == 'pepper':        salt_pepper = 0.5        noisy_img = np.copy(image)        num_salt = np.ceil(amount * image.size * salt_pepper)        coords = [np.random.randint(0, i - 1, int(num_salt)) for i in image.shape]        noisy_img[coords[0], coords[1]]= 255        num_pepper = np.ceil(amount * image.size * (1. - salt_pepper))        coords = [np.random.randint(0, i - 1, int(num_pepper)) for i in image.shape]        noisy_img[coords[0], coords[1]] = 0        return noisy_img    if mode == 'spot':        gauss = np.random.randn(image.shape[0],image.shape[1])        noisy_img = image + image * gauss        noisy_img = np.clip(noisy_img, a_min=0, a_max=255)        return noisy_imgdef GaussianFrequencyFilter(image, sigma):    imarr = np.array(image)    height, width = imarr.shape    fft = np.fft.fft2(imarr)    fft = np.fft.fftshift(fft)    for i in range(height):        for j in range(height):            fft[i, j] *= np.exp(-((i - (height - 1) / 2) ** 2 + (j - (width - 1) / 2) ** 2) / 2 / sigma ** 2)    fft = np.fft.ifftshift(fft)    ifft = np.fft.ifft2(fft)    ifft = np.real(ifft)    max = np.max(ifft)    min = np.min(ifft)    res = np.zeros((height, width), dtype="uint8")    for i in range(height):        for j in range(width):            res[i, j] = 255*(ifft[i, j] - min) / (max - min)    return resdef notch_filter(img, h, w):    print(img)    rows, cols = img.shape    center = [int(rows / 2), int(cols / 2)]    mask = np.zeros((rows, cols), np.float32)    for u in range(rows):        for v in range(cols):            mask[u,v]=0    for u in range(rows):        for v in range(cols):            if abs(u - center[0]) < h and abs(v - center[1]) < w:                mask[u, v] = 1    return maskdef magnitude_phase_split(img):    dft = np.fft.fft2(img)    dft_shift = np.fft.fftshift(dft)    magnitude_spectrum = np.abs(dft_shift)    phase_spectrum = np.angle(dft_shift)    return magnitude_spectrum, phase_spectrumdef magnitude_phase_combine(img_m, img_p):    img_mandp = img_m * np.e ** (1j * img_p)    img_mandp = np.uint8(np.abs(np.fft.ifft2(img_mandp)))    img_mandp = img_mandp / np.max(img_mandp) * 255    return img_mandp